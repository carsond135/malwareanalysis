## LAB2实验报告

 专业：信息安全  姓名：魏伯繁   学号：2011395  

一、实验环境

本地：win10操作系统，16GB内存，2.9GHz主频

二、实验工具：

win10操作系统、yara工具包、python3-10编译器、pycharm、python-yara工具包

三、实验内容

1、根据LAB1中分析得到的程序特性，编写yara代码

```python
import "pe"
rule IsPE{
    meta:
        description = "检查文件是否为PE文件"
        author="wbf"
        date="2022-10-12"
    condition:
        uint16(0) == 0x5A4D and //“MZ”头
        uint32(uint32(0x3C)) == 0x00004550 // “PE”头

}

rule smallFileSize{
	meta:
		description = "检查文件小是否大概率为exe文件"
        		author="wbf"
        		date="2022-10-15"
	condition:
		filesize<500KB
}

rule mayBeMaleware{
	meta:
		description = "检查文件小是否大概率为maleware文件"
        		author="wbf"
        		date="2022-10-15"
	strings:
		$a = { E8 00 00 00 00 }
	condition:
		$a at pe.entry_point
}

rule visitDIskCSystemFile{
    meta:
        description="检查对于C盘下重要系统文件的访问"
        author="wbf"
        date="2022-10-12"
    strings:
        $a = "C:\\windows\\system32"
        $b = "\\kernel"
        $c = "\\system32"
    condition:
        ($a or $b or $c) and IsPE and smallFileSize
}

rule operateFile{
    meta:
        description="检查是否对文件进行操作"
        author="wbf"
        date="2022-10-12"
    strings:
        $a= "CopyFileA" ascii
        $b="CreateFileA" ascii
        $c="writefile" nocase
    condition:
        IsPE and ($a or $b or $c) and smallFileSize
}

rule UPXShelling{
    meta:
        description="UPX技术加壳"
        author="wbf"
        date="2022-10-12"
    strings:
        $a = "UPX"
    condition:
        IsPE and $a and smallFileSize
}

rule CallTheFunction{
    meta:
        description="该程序使用运行时链接，不能只看其导入表，需要分析其程序本身"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="LoadLibraryA"
        $b="GetProcAddress"
    condition:
        $a and $b and IsPE and smallFileSize
}

rule VisitInternet{
    meta:
        description="该程序很有可能访问了互联网"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="WININET.dll"
        $b="InternetOpenA"
        $c="http"
        $d="https"
        $e="www"
        $f="ws2_32" nocase
    condition:
        ($a or $b or $f) or ($c or $d or $e) and IsPE and smallFileSize

}

rule DownloadFromInternet{
    meta:
        description="从网上下载内容"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="URLDownloadToFile"
    condition:
        $a and IsPE and smallFileSize
}

rule CallNewEXE{
    meta:
        description="可能会调用新的EXE文件"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="winexec" nocase
    condition:
        $a and IsPE and smallFileSize
}

rule ISMaybeKnownMalware{
    meta:
        description="包含已有病毒的名字，可能是病毒"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="winup" nocase
        $b="malware" nocase
    condition:
        IsPE and ($a or $b) and smallFileSize
}

rule operatePermission{
    meta:
        description="进行与权限有关的操作"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="advapi32" nocase
        $b="privilige" nocase
        $c="process" nocase
    condition:
        IsPE and ($a or ($b and $c)) and smallFileSize
}


```

分析：具体每个规则在meta段已经得到了基本叙述，简述设计思路：就是通过对原程序恶意代码的分析，提取出其中关键的字符串或者关键代码作为特征，通过编写yara规则来识别这些特征，可用的规则包括直接提供原字符串或代码片段，也可以使用扩展性更强的正则表达式等来表示特征。

截取其中某一yara规则进行说明：

​		meta段声明改规则用来识别那些使用了运行时连接的PE文件，如果某一文件具有该规则的特征，说明其调用了LoadLibraryA函数以及GetProcAddress函数，即程序通过运行时连接的方式调用函数，该函数可能不在导入表中，需要我们进一步结合其其他规则特性进行反汇编代码查看进行分析

​		所以在条件段我给出了必须满足两个函数名同时出现才算该规则生效，并且该文件还必须是一个PE文件并且他的大小还不能太大。于是我们可以得到条件判断语句中的四个条件。

```python
rule CallTheFunction{
    meta:
        description="该程序使用运行时链接，不能只看其导入表，需要分析其程序本身"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="LoadLibraryA"
        $b="GetProcAddress"
    condition:
        $a and $b and IsPE and smallFileSize
}
```

2、扫描C盘文件：

思路：使用python-yara库通过递归寻找文件进行逐个扫描，使用输出重定向将其输出到新建的txt文件中。当然，C盘中的很多文件我们并没有扫描权限，所以需要增加try-catch语句块对不能处理的异常文件or文件夹进行处理。

```python
#!/usr/bin/env.python
# -*- coding: utf-8 -*-

import yara
import os
import sys
import time

# 获取目录内的yara规则文件
# 将yara规则编译
def getRules(path):
    filepath = {}
    for index, file in enumerate(os.listdir(path)):
        rupath = os.path.join(path, file)
        key = "rule" + str(index)
        filepath[key] = rupath
    yararule = yara.compile(filepaths=filepath)
    return yararule

# 扫描函数
def scan(rule, name):
    try:
        if(os.path.isfile(name)):
            fp=open(name,'rb')
            matches=rule.match(data=fp.read())
            if len(matches)>0:
                print(name,matches)
                return
            else:
                return
        else:
            for file_ls in os.listdir(name):
                scan(rule,os.path.join(name,file_ls))
    except (PermissionError, OSError):
        print("无法打开文件 " + name)


if __name__ == '__main__':
    time_start = time.time()
    rulepath = "D:\yara\yararules\lab1yara\lab1yar"   # yara规则目录
    malpath ="C:\\" # simple目录
    # yara规则编译函数调用
    yararule = getRules(rulepath)
    print("yara规则收集成功，正在扫描文件......")
    oldstdout = sys.stdout
    file = open(r'C:\Users\魏伯繁\Desktop\\test.txt', 'w', encoding='utf-8')
    sys.stdout = file
    # 扫描函数调用
    scan(yararule, malpath)
    file.close()
    sys.stdout=oldstdout;
    time_end = time.time()
    time_c = time_end - time_start  # 运行所花时间
    print('time cost', time_c, 's')


```

查看扫描时间：可以看到，yara对C盘下的53万多个文件进行扫描需要的时间是1000多秒，因为编写的规则相对简单而且并不全面，所以执行速度相对快一些。

![](G:\code\MalewareAnalysis\lab1yara\1.png)

![](G:\code\MalewareAnalysis\lab1yara\2.png)

截取一部分分析片段进行查看：可以看到，截取的这一部分和我的本机（联想）的内部处理有关，很多关于更新检查、软件更新的操作是通过部分文件完成的，所以可以看到，他们绝大部分都具有访问网络的功能，另外一小部分具有操作文件（例如下载、删除）的功能。

```cassandra
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\GenericMsgHelper.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Keyboard_Core.dll [IsPE, smallFileSize, VisitInternet, operatePermission]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.Contracts.ActivePenPluginContracts.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.Contracts.Battery.Common.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.Contracts.PointingDeviceContracts.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.Contracts.SystemManagement.Power.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.CoreTypes.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.ImController.ImClient.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.ImController.PluginUtilities.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\Lenovo.Modern.Utilities.dll [IsPE, smallFileSize, operateFile, VisitInternet, operatePermission]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\LenovoActivePenLocationHelper.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\LenovoActivePenNotifications.dll [IsPE, smallFileSize, VisitInternet]
C:\Program Files (x86)\Lenovo\PCManager\5.0.50.9282\Modules\Setings\x64\LenovoKBDManagerPlugin.dll [IsPE, smallFileSize, VisitInternet]
```

3、讨论Yara的执行效率问题：

（1）匹配范围的问题：

如果一个特征字符在整个exe文件中都有可能出现，那么说明yara需要从头至尾扫描整个文件来判断其是否出现，例如如下代码片段：

```python
rule CallNewEXE{
    meta:
        description="可能会调用新的EXE文件"
        author="wbf"
        date="2022-10-12"
    strings:
        $a="winexec" nocase
    condition:
        $a and IsPE and smallFileSize
}
```

我不能判定他到底会在哪里可能出现，所以为了我检测的完整性和精确度，我只能牺牲一部分时间来完成任务。

但是对于某些有特定规律的识别，指定某一个特征出现在哪里或哪个范围可以大大的减少扫描时间，增加扫描效率，比如如果我知道winexec只会出现在200-300这个范围内，那么我就可以编写：

```python
$a in (200..300)
```

来帮助程序指定一个位置进行匹配

（2）特征匹配范围

众所周知，正则表达式可以很好的通过简短的语言表达非常复杂的特征，但是这样也必然意味着yara扫描时需要考虑到无穷多种可能性来与正则表达式作比对，这样是很降低效率的，同样的也有诸如“？？”以及[1,5]这样的不确定性匹配会大大提升程序开销，对于确定的有特殊含义的字符，尽量减少他的不确定性以提升程序的性能：

```python
rule IsPE{
    meta:
        description = "检查文件是否为PE文件"
        author="wbf"
        date="2022-10-12"
    condition:
        uint16(0) == 0x5A4D and //“MZ”头
        uint32(uint32(0x3C)) == 0x00004550 // “PE”头

}
```

（3）减少在低可能高开销程序上的时间

比如：一个大于1G的文件很可能是一个视频或者音频文件，他是恶意代码的概率是极低的，但是扫描这样的文件所需要的开销却是极大的，于是我们可以利用yara规则中的一些全局判定来帮我们减少开销：

```c
filesize < 1024MB //过滤大文件
```

（4）充分利用已有规则进行组合，避免重复检测

在yara中允许使用include包含其他规则的内容，我们可以充分整合之前的代码，在完善旧代码的同时完成对新条件的添加，避免对同一个规则进行重复检测，增加开销。