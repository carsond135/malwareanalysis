## 课本实验12实验报告

姓名：魏伯繁 学号：2011395 专业：信息安全

第一部分：Lab12-01

1、在你运行这个恶意代码可执行文件时，会发生什么

2、哪个进程会被注入

3、你如何能够让恶意代码停止弹出窗口？

4、这个恶意代码样本是如何工作的？

第一步：基本静态分析，在基本静态分析中，我们可以看到基于Lab12-01.exe的导入函数，我们看见了：CreateRemoteThread、WriteProcessMemory以及VirtualAllocEx，我们可以判定这可能是基于某种形式的进程注入恶意代码

![](G:\code\MalewareAnalysis\lab12\pic1\2.png)

当然，我们还可以看到一些其他的有意思的字符串，比如：explorer.exe、Lab12-01.dll以及psapi.dll

![](G:\code\MalewareAnalysis\lab12\pic1\10.png)

接下来，我们使用动态分析技术，当我们运行这个恶意代码时他每分钟都会弹出一个消息框，并且还会对弹出的次数进行计次，但是Procmon以及Process Explorer都没有什么明显的恶意进程以及恶意行为可以被观察到

![](G:\code\MalewareAnalysis\lab12\pic1\1.png)

![](G:\code\MalewareAnalysis\lab12\pic1\11.png)

然后，我们使用IDAPRO对恶意代码进行分析，在main函数刚开始的几行里可以看到这个代码正在解析psapi.dll中Windows枚举进程的函数，恶意代码使用了LoadLibrary和GetProcAddress来手动的解析3个函数：恶意代码保存指向408714/40870C以及408710的函数指针，他们分别代表了EnumProcessModules、GetModuleBaseNameA以及EnumProcesses，在动态解析结束后这段代码调用EnumProcess来获取在系统中每一个进程对象的PID。EnumProcesses返回一个由局部变量dwProcessId引用的PID数组，该引用将一个列表中的进程列表调用sub_401000

![](G:\code\MalewareAnalysis\lab12\pic1\12.png)

然后，我们来查看401000的代码，当动态解析的导入函数EnumProcessMoudles在PID被传给OpenProcess函数后被调用，然后我们就调用GetModuleBaseNameA，其中dword_40870C代表着GetModuleBaseNameA函数将PID翻译为进程名，然后我们将得到的字符串和explorer.exe进行比较赖在内存空间中找到explorer.exe

![](G:\code\MalewareAnalysis\lab12\pic1\13.png)

如果成功找到了该进程那么则返回1，main函数会调用OpenProcess来打开一个指向他的句柄，如果这个恶意代码成功改的返回了一个这个进程的句柄那么就执行下面的代码：调用一个VirtualAllocEx动态的explorer.exe中分配内存，上面提到的0x104字节通过压栈的方式当做参数传递，如果内存分配成功，一个指向被分配空间的lpBaseAddress会被移动到该句柄中。

![](G:\code\MalewareAnalysis\lab12\pic1\5.png)

该句柄和进程句柄hprocess会被当做参数一起传递给WriteProcessMemory以便向explorer.exe中传递数据，写入这个进程的数据存储在了lpBuffer中

![](G:\code\MalewareAnalysis\lab12\pic1\6.png)

如果上面的内容成功写入了则会进入下面代码的执行首先调用GetModuleHandleA以及GetProcAddress来获取LoadLibraryA的地址。在本恶意样本中LoadLibrary和explorer.exe的地址相同，于是使用指令

```assmble
mov [ebp+lpStartAddress]， eax
```

来讲LoadLibraryA的地址写入lpStarAddress中，CreateRemoteThread的参数lpStarAddress参数强制explorer.exe调用LoadLibraryA。他的参数通过CreateRemoteThread中的lpParameter传递，也即是包含Lab12-01的字符串，于是，在远程进程中启动一个线程，这个线程以参数Lab12-01.dll来调用LoadLibraryA。我们现在可以断定这个恶意代码进行了DLL注入，将Lab12-01.dll注入到explorer.exe中

![](G:\code\MalewareAnalysis\lab12\pic1\7.png)

当我们知道什么东西被注入了时就可以想办法去停止他，使用Process Explorer来进行停止恶意代码的运行，我们可以看到在explorer.exe中载入了Lab12-01.dll，在确定我们的分析无误后，我们可以使用Process Explorer来停止该进程的执行，然后再通过在Run中输入explorer重启进程

于是我们可以明确的是，恶意代码的功能都是由dll文件提供的，于是我们分析dll文件：我们可以看到其开启了一个新的线程，线程调用的函数的句柄为lpStartAddress，他用来创建消息框并显示Press OK to reboot，他用一个sprintf拼接的参数作为这个消息框的标题，这个参数用Format字符串来显示“Practical Malware Analysis”+其对话框弹出的次数，每次执行都都会睡眠60s然后再次执行

![](G:\code\MalewareAnalysis\lab12\pic1\9.png)

第二部分：Lab12-02

1、这个程序的目的是什么？

2、启动器恶意代码是如何隐蔽执行的？

3、恶意代码的负载存储在哪里？

4、恶意负载是被如何保护的？

5、字符串列表是被如何保护的？

通过静态分析，除了导入表的函数名外似乎找不到更多的有用的信息，于是我们针对导入表的信息进行分析，可以看到CreateProcessA、GetThreadContext以及SetThreadContext暗示这个程序创建新的进程并修改进程中的线程的上下文

![](G:\code\MalewareAnalysis\lab12\pic2\1.png)

接下来导入函数ReadProcessMemory和WriteProcessMemory告诉我们这个程序对进程内存空间进行了直接读写

![](G:\code\MalewareAnalysis\lab12\pic2\2.png)

导入函数LockResource和SzieOfResource告诉我们这个进程比较重要的数据可能存在资源节中

![](G:\code\MalewareAnalysis\lab12\pic2\3.png)

随后我们启用高级静态分析来准确识别其实现的具体功能形式：首先我们将注意力集中在CreateProcessA--创造进程的函数调用上，首先，他压入了一个参数为4，其对应的参数名为dwCreationFlags。微软官方对该函数的描述表明该位置是描述CREATE_SUSPENDED标志，他允许这个进程被创建但是不被启动。这个进程不会被执行，除非等待这个主进程的API ResumeThread函数时才会被启动

![](G:\code\MalewareAnalysis\lab12\pic2\4.png)

而在后面它又调用了访问线程上下文的函数，而作为函数参数传递的hThread在前面一张图中的lpProcessInformation处于同一缓冲区，它告诉我们这个程序正在访问挂起的进程的上下文。或其与进程的句柄非常重要，因为程序将使用进程句柄与挂起进程进行交互

![](G:\code\MalewareAnalysis\lab12\pic2\5.png)

调用GetThreadContext之后，这个进程被用于ReadProcessMemory的调用。代码如下图所示：这个新创建就被挂起EBX寄存器总是指向一个指向进程环境块PEB的数据结构，通过在004011c9处递增8字节递增结构体并将这个值压入到栈上，作为要读取内存的起始地址。因为PEB不是IDAPRO数据结构中的一部分，但我们可以在网上查找到关于PEB的相关资料，在偏移为8的位置为ImageBase

![](G:\code\MalewareAnalysis\lab12\pic2\6.png)

其中，进程环境块的定义如下：参考网址如下：

[(117条消息) Process Environment Block（PEB）_寻梦&之璐的博客-CSDN博客](https://blog.csdn.net/CSNN2019/article/details/113113347)

```c++
typedef struct _PEB { // Size: 0x1D8
 	000h    UCHAR           InheritedAddressSpace;
    001h    UCHAR           ReadImageFileExecOptions;
    002h    UCHAR           BeingDebugged;              //Debug运行标志
    003h    UCHAR           SpareBool;
    004h    HANDLE          Mutant;
    008h    HINSTANCE       ImageBaseAddress;           //程序加载的基地址
    00Ch    struct _PEB_LDR_DATA    *Ldr                //Ptr32 _PEB_LDR_DATA
    010h    struct _RTL_USER_PROCESS_PARAMETERS  *ProcessParameters;
    014h    ULONG           SubSystemData;
    018h    HANDLE          DefaultHeap;
    01Ch    KSPIN_LOCK      FastPebLock;
    020h    ULONG           FastPebLockRoutine;
    024h    ULONG           FastPebUnlockRoutine;
    028h    ULONG           EnvironmentUpdateCount;
    02Ch    ULONG           KernelCallbackTable;
    030h    LARGE_INTEGER   SystemReserved;
    038h    struct _PEB_FREE_BLOCK  *FreeList
    03Ch    ULONG           TlsExpansionCounter;
    040h    ULONG           TlsBitmap;
    044h    LARGE_INTEGER   TlsBitmapBits;
    04Ch    ULONG           ReadOnlySharedMemoryBase;
    050h    ULONG           ReadOnlySharedMemoryHeap;
    054h    ULONG           ReadOnlyStaticServerData;
    058h    ULONG           AnsiCodePageData;
    05Ch    ULONG           OemCodePageData;
    060h    ULONG           UnicodeCaseTableData;
    064h    ULONG           NumberOfProcessors;
    068h    LARGE_INTEGER   NtGlobalFlag;               // Address of a local copy
    070h    LARGE_INTEGER   CriticalSectionTimeout;
    078h    ULONG           HeapSegmentReserve;
    07Ch    ULONG           HeapSegmentCommit;
    080h    ULONG           HeapDeCommitTotalFreeThreshold;
    084h    ULONG           HeapDeCommitFreeBlockThreshold;
    088h    ULONG           NumberOfHeaps;
    08Ch    ULONG           MaximumNumberOfHeaps;
    090h    ULONG           ProcessHeaps;
    094h    ULONG           GdiSharedHandleTable;
    098h    ULONG           ProcessStarterHelper;
    09Ch    ULONG           GdiDCAttributeList;
    0A0h    KSPIN_LOCK      LoaderLock;
    0A4h    ULONG           OSMajorVersion;
    0A8h    ULONG           OSMinorVersion;
    0ACh    USHORT          OSBuildNumber;
    0AEh    USHORT          OSCSDVersion;
    0B0h    ULONG           OSPlatformId;
    0B4h    ULONG           ImageSubsystem;
    0B8h    ULONG           ImageSubsystemMajorVersion;
    0BCh    ULONG           ImageSubsystemMinorVersion;
    0C0h    ULONG           ImageProcessAffinityMask;
    0C4h    ULONG           GdiHandleBuffer[0x22];
    14Ch    ULONG           PostProcessInitRoutine;
    150h    ULONG           TlsExpansionBitmap;
    154h    UCHAR           TlsExpansionBitmapBits[0x80];
    1D4h    ULONG           SessionId;
	1d8h AppCompatFlags   : _ULARGE_INTEGER
	1e0h AppCompatFlagsUser : _ULARGE_INTEGER
	1e8h pShimData        : Ptr32 Void
	1ech AppCompatInfo    : Ptr32 Void
	1f0h CSDVersion       : _UNICODE_STRING
	1f8h ActivationContextData : Ptr32 Void
	1fch ProcessAssemblyStorageMap :Ptr32 Void
	200h SystemDefaultActivationContextData : Ptr32 Void
	204h SystemAssemblyStorageMap : Ptr32 Void
	208h MinimumStackCommit : Uint4B
} PEB, *PPEB;

```

这个程序在0x004011E8的GetProcessAddress手动解析导入函数NtUnmapViewOfSection

![](G:\code\MalewareAnalysis\lab12\pic2\7.png)

并且在004011FE处，ImageBaseAddress作为UnmapViewOfSection的一个参数传入。UnmapViewOfSection的调用从内存中移除这个被挂起的进程，此时这个车程序将不再执行

![](G:\code\MalewareAnalysis\lab12\pic2\8.png)

随后，我们可以看到参数被压倒栈上，然后调用VirtualAllocEx，其中作为参数被压入的40h显示了这个程序再被挂起进程的地址空间中分配内存，然后咋ecx+34得位置，这个程序要求内存被分配在PE文件的ImageBase的地址，它告诉Windows加载器这个可执行文件更偏向于加载到哪个位置，随后在eax，[edx+50h]这个程序由PE头imageBase属性指定内存的大小，最终在分配的权限包括可执行以及可写

![](G:\code\MalewareAnalysis\lab12\pic2\9.png)

早在这个程序开始前，程序检查0x004010FE处的magic value值MZ也就是4D5A同理检查0x00401119处的MZ，如果这个检查成功则var_8指向内存的PE头

![](G:\code\MalewareAnalysis\lab12\pic2\10.png)

一旦这部分内存被分配后，在0x00401251的指令会调用WriteProcessMemory函数，从这个PE文件的开头写入数据到挂起进程时分配的内存中，要写入的字节数从PE头的0x54处获得，也即是SizeOfHeaders。第一次WriteProcessMemory调用将PE文件头复制到被挂起的进程中，这个行为表明了程序正在移动一个PE文件到另一个进程空间中：

![](G:\code\MalewareAnalysis\lab12\pic2\11.png)

接下来，我们可以看到一个循环，这个循环计数器var_70在0x00401257处被初始化为0，这个循环计数器用来与00401272位置的第六子街偏移处的值作比较，也就是NumberOfSection。因为这个可执行代码包含一个可执行文件所必须的数据--如代码。数据。重定位等等，所以我们知道这个循环正在赋值PE可执行段到这个挂起线程

具体的进行分析：var_4变量包含了一个指向内存中PE文件的指针，也就是lpBuffer，他在0x004010F3的位置被初始化，在接下来的0x0040127D的位置，我们看到程序在将MZ头缓冲区的偏移量加上0x3C，也就是到PE头的变异量，这使得ECX现在指向了PE头的位置，于是在后面我们可以看到程序获取了一个指针，在edx这个循环中第一次迭代时的值为0，所以我们可以在指针计算中将EDX移除，这样就只剩ECX和0xF8了

PE文件头的结构中0XF8是Image_Header_Section的起始位置，一个乘法将其结构所占字节算出可以告诉我们他占用了40字节，这与16进制值28h符合

![](G:\code\MalewareAnalysis\lab12\pic2\14.png)

那么，根据前面的分析，我们就可以知道后面的代码进行的工作，起始就是将PE文件对应的每一个段都复制到被挂起的进程空间中，至此，这个程序就完成了加载一个可执行文件到另一个进程的地址空间的工作。在下面的代码中，可以在0x00401272处看到一个循环，这个循环在后面的图片中展示了，他被初始化为0

上面所说的循环计数器将用来与PE头部的第六个字节的偏移作比较，也就是NumberOfSection，因为可执行代码包含一个可执行文件所必须的数据，比如代码、数据、重定位信息等等，所以我们可以知道这个循环可能正在复制PE可执行段到这个挂起进程

其中var_4变量包含一个指向内存中PE文件的指针，也就是lpBuffer，这在下面的图片中也展示了其初始化的过程，在0x0040127D的位置这个程序将MZ头的缓冲区偏移量加上0X3C，也就是到PE头的偏移，这让ecx指向了PE头的位置，随后马上一个指针被获取。EDX在这个循环第一次迭代时的值为0，所以现在指针就只剩ECX以及0XF8

0XF8在PE文件头中时是IMAGE_HEADER_SECTION数组的位置，这个结构的大小也可以很简单的被计算出为40字节

下面代码的意义就变得清晰了起来，他复制了每一个段，也就是程序赋值每一个段到挂起的进程空间中，于是通过下面的代码就可以完成加载一个可执行文件到另一个进程的地址空间的必要步骤

![](G:\code\MalewareAnalysis\lab12\pic2\12.png)

lpBuffer以及var_4的初始化过程：

![](G:\code\MalewareAnalysis\lab12\pic2\13.png)

对于循环开始次数的初始化

![](G:\code\MalewareAnalysis\lab12\pic2\15.png)

在下面的函数中，我们看到这个程序调用了SetThreadContext，这个函数在0x004012E7处将ecx寄存器加载为被挂起进程内存空间中可执行文件的入口点，如果这个程序在004012FF处执行了ResumeThread函数，他就会成功到达之前CreateProcessA创建的进程替换为另一个进程的目的

![](G:\code\MalewareAnalysis\lab12\pic2\16.png)

我们经过前面的分析已经明白了这个恶意代码的目的就是完成对挂起进程的替换，那么我们现在就需要知道其到底对哪一个进程完成了进程替换。于是代码中使用的lpApplicationName的来源便成为了重中之重，使用交叉引用可以在00401508的位置找到对该变量的初始化

我们可以发现，在00401514中出现了svchost.exe的字符串，并且在这之后马上将其作为参数压入栈中并调用另外一个函数，起作用就是调用函数获取系统目录，然后将二者拼接，那么我们不难推断出这个恶意代码完成了对svchost.exe的替换

![](G:\code\MalewareAnalysis\lab12\pic2\18.png)

![](G:\code\MalewareAnalysis\lab12\pic2\19.png)

在svchost程序启动后还需要判断要替换的svchost进程，我们通过对0x00401539的变量lpBuffer的跟踪发现可以定位到0x00401521位置，在第一个call位置更新了EAX的值，很明显，他马上使用变量hmoudle即一个指向程序本身的内存指针：

![](G:\code\MalewareAnalysis\lab12\pic2\20.png)

函数40132C调用函数FindResource、LoadResource、LockResource、SizeOfResource、virtualAlloc以及memcpy，这个程序从可执行文件的资源端复制数据到内存中，我们将使用ResourceHacker来查看资源端中的向并将它导出到单独文件中

我们继续查看反汇编代码，在0x00401425的位置，我们看到这个缓冲区被传递给参数sub_401000，这个函数看起来向一个XOR程序，回顾传递给0x0040141B的第三个参数0x41可以发现异或的密钥就是0x41

![](G:\code\MalewareAnalysis\lab12\pic2\21.png)

那么，我们可以利用工具WINHEX来进行异或解密，发现解密结果是一个exe文件，也就是替换svchost的可执行文件

![](G:\code\MalewareAnalysis\lab12\pic2\22.png)

第三部分：Lab12-03

1、这个恶意负载的目的是什么

2、恶意负载是如何注入自身的

3、这个程序还创建了哪些其他文件

我们首先还是使用基本静态分析来对该恶意代码进行分析，使用strings工具得到的答案不难发现他很有可能是一个击键记录器，大量的特殊键的名字暴露了他的功能

![](G:\code\MalewareAnalysis\lab12\pic3\1.png)

接下来，我们使用IDAPro来对其进行分析：不难观察到，一个挂钩函数在main函数中被调用，其中第一个参数0Dh对应WH_KEYBOARD_LL，其使用IDAPro标记为fn的挂钩函数启用键盘事件监控，这个程序很有可能对击键消息进行了记录

![](G:\code\MalewareAnalysis\lab12\pic3\2.png)

注册该钩子之后，程序在0x00401076处的循环中调用了GetMessageA，在本例中程序一定要调用GetMessageA，因为Windows不会将消息发送到程序进程的钩子函数中，所以一直到函数循环结束才会终止。

![](G:\code\MalewareAnalysis\lab12\pic3\3.png)

下面我们负fn函数进行分析，fn是一个通用函数，它一共需要3个参数，其中存在一个定义为HOOKPROC的原型。我们可以通过查阅资料确定WH KEYBOARD LL回调函数实际上是LowLevelKeyboardProc回调函数。

为了处理每次按键，程序用cmp指令在O和e处检查按键的类型。程序将虚拟按键码传递到随后以粗体显示的sub 401C7函数中。

![](G:\code\MalewareAnalysis\lab12\pic3\4.png)

下面我们查看sub 4010C7函数，可以看到程序首先打开文件practicalmalwareanalysis.log，然后恶意代码调用GetForegroundwindow和GetWindowTextA，首先，GetForegroundWindow选择按键按下时的活动窗口，然后使用GetwindowTextA获得窗口的标题。通过这些操作，帮助程序提供按键来源的上下文。

![](G:\code\MalewareAnalysis\lab12\pic3\5.png)

![](G:\code\MalewareAnalysis\lab12\pic3\7.png)

一旦程序将窗口标题写入到日志文件，它就进入一个跳转表，确定变量var C包含传入函数sub 401C7的虚拟按键码后，可以看到虚拟按键码作为一个查询表的索引2。查询表得到的值作为跳转表off401441的一个索引

选择和键盘 SHIFT对应的值，可以在程序中跟随查询过程。从这个值中减去8，剩下的值为0x8(0x10-0x08)。在byte 40148D查找偏移量0x8。可以得到结果为值3，3被存入到ECX中。然后,ECX乘以40,得到0xC,将它作为off 41441的一个偏移量,然后返回到位置10c 401249,这里我们发现字符串[SHIFT1被写入到日志文件中。

![](G:\code\MalewareAnalysis\lab12\pic3\8.png)

于是，我们可以判断他是一个击键记录器，他讲击键记录到文件practicalmalwareanalysisi.log中这个击键记录器使用挂钩来实现相应功能

![](G:\code\MalewareAnalysis\lab12\pic3\9.png)