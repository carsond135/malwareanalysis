课本第十章练习实验报告

专业：信息安全  姓名：魏伯繁 学号：2011395

第一部分：实验分析

WinDbgX.exe -k com:port=\\.\pipe\com_2,baud=115200,pipe

Lab10-01：

1、这个程序是否直接修改了注册表？（使用procmon来检查）

2、用户态的程序调用了ControlService函数，你是否能使用WinDbg设置一个断点，以此来观察由于ControlService的调用导致内核执行了怎样的操作。

3、这个程序做了什么？

分析过程

第一步：使用基本静态分析检查代码：

利用strings工具查看其基本组成：在exe中可以看到这个程序会启动一个服务，并且注册一个服务

![](G:\code\MalewareAnalysis\lab10\pic1\1.png)

并且，一个很有用的信息就是在最后出现了一个RegWriteApp的字符串，代表了这个exe文件是一个可以修改注册表的可执行程序

![](G:\code\MalewareAnalysis\lab10\pic1\2.png)

对sys文件使用strings工具验证了我们的猜想，这个程序会对注册表进行修改并注册服务

![](G:\code\MalewareAnalysis\lab10\pic1\3.png)

当然，更重要的是：其包含了一些注册表键值，前缀\register\machine响相当于用户态程序访问HKEY_LOCAL_MACHINE，上面的EnableFirewall就是关闭了windows的防火墙

![](G:\code\MalewareAnalysis\lab10\pic1\5.png)

再使用PEBrowser查看sys文件，可以看到他具有三个导入函数：后两个函数都是对注册表的修改所需要的API函数

![](G:\code\MalewareAnalysis\lab10\pic1\4.png)

第二步：使用IDAPro分析文件

首先我们通过IDAPro打开exe文件，发现他主要做的事情就是在注册服务，首先通过OpenSCMangerA获取服务管理器的句柄，然后创建一个名字叫做Lab10-01的服务，并且调用了C:\\Windows\\System32\\Lab10-01.sys中的代码，而根据下面的StartType=3判断这个文件会被加载进入内核。

如果成功打开，那么就跳转到401069，如果失败则调用OpenServiceA，代表这个服务在宿主机中已经存在而，不用反复感染，只需要直接返回句柄操作即可。

![](G:\code\MalewareAnalysis\lab10\pic1\6.png)

而在最后有一个ControlService函数，根据参数的Control=1判断这个函数的调用将会卸载驱动，并调用驱动的卸载函数。

![](G:\code\MalewareAnalysis\lab10\pic1\7.png)

随后，我们通过IdaPro打开sys文件：一个驱动对象作为参数被传递，整个DriverEntry的结构非常短小，他只是将一个由参数所提供的位置的固定偏移量加载如内存，除此之外再没有其他动作。

![](G:\code\MalewareAnalysis\lab10\pic1\8.png)

第三步：使用基本动态分析工具procmon分析，发现他确实对注册表有打开、查询等行为，但暂时没有找到具体的更改注册表的操作，这些需要通过进一步的内核调试来完成

![](G:\code\MalewareAnalysis\lab10\pic1\20.png)

第四步：内核调试

紧接着，我们就可以使用内核调试来获得详细的程序对内核的操作了：

为了在Lab10-01.sys载入内存后使用windbg分析他，在虚拟机中，我们将可执行程序载入到windbg中，使用如下命令可以在驱动加载以及卸载之间打上一个断点，在打断点之前使用lm命令查看目前的模块内容，然后启动程序直到断点命中，当断点命中之后可以观察到如下信息：

![](G:\code\MalewareAnalysis\lab10\pic1\9.png)

此时，因为sys文件已经成功载入内存，所以我们返回win10宿主机对xp虚拟机进行内核调试。具体的环境配置方法可以参考网上很多的教程，本人踩的坑就是需要把端口号注册为com_2，我是没有打印机也要注册成com_2，否则会出现一直连不上虚拟机的情况出现。然后我们就可以通过！drvobj命令来获取驱动对象

![](G:\code\MalewareAnalysis\lab10\pic1\11.png)

于是我们获得了驱动对象的地址，这个驱动对象是我们在进程中可以获得的，同样可以观察到列表的设备为空，所以可以分析得到这个驱动没有供用户空间中应用程序访问的设备。

于是，我们获取了驱动对象以及其地址8a02a460，使用dt命令查看驱动对象：可以找到卸载时调用的函数，函数的地址为0xba672486

![](G:\code\MalewareAnalysis\lab10\pic1\14.png)

接着，在宿主机设置断点，并且恢复执行，随后在xp中同样使用g命令恢复执行，非常快程序就执行到了断点，此时xp卡死，我们退回到宿主机查看到了一条汇编代码，我们使用单步调试分析后续的指令

![](G:\code\MalewareAnalysis\lab10\pic1\15.png)

可以观察到程序调用了三次CreateRegistryKey函数，创建了注册表键然后两次调用WriteRegistryValue在两个地方将防火墙的值设置为0

![](G:\code\MalewareAnalysis\lab10\pic1\17.png)

![](G:\code\MalewareAnalysis\lab10\pic1\18.png)

我们可以不在windbg中调试冗长的卸载函数，而是在IDA pro中完成分析，使用lm指令可以发现文件被加载到ba672000，卸载函数被加载到ba672486，然后可以通过在IDAPro中加上基址的方式找到卸载函数

![](G:\code\MalewareAnalysis\lab10\pic1\16.png)

也就是在这里，我们再次返回到用IDAPro加载sys文件：可以看到在基址（0x00100000）+0x486位置果然出现了刚才分析的函数

![](G:\code\MalewareAnalysis\lab10\pic1\19.png)

Lab10-02：

1、这个程序创建文件了吗？它创建了什么文件

2、这个程序有什么内核组件吗？

3、这个程序做了什么？

分析过程：

先说明一下，这个lab我的xp虚拟机不知道在抽什么疯，一直告诉我他在把那个Mlwx486写入一个只读内存，我也是前前后后研究了一个多小时都没有弄明白哪里出了问题，甚至回到了10月的虚拟机再试也不行，所以说这篇关于内核调试的方法以及思路包括图片来源于互联网，我会在这个lab的末尾明确标注出来，但是所有静态调试都是自己的截图以及思路。

第一部分：基本静态分析：

首先，通过分析导入表我们得知，该exe文件导入了StartServiceA和CreateServiceA，这个exe文件想要注册一个服务并且开启这个服务

![](G:\code\MalewareAnalysis\lab10\pic2\1.png)

接下来我们发现，这个文件的资源节很特殊，他可以直接被PEBrowser识别为一个二进制文件，于是我们点击资源节可以看到：我们可以精准的识别出一个PE文件呢的头部，那么相当于这个exe携带了另一个文件的代码，那么我们猜测他很有可能是要将这个代码放置在某个地方并为这个文件注册为服务。

![](G:\code\MalewareAnalysis\lab10\pic2\2.png)

紧接着，我们使用procmon监视进程，发现这个可执行文件使用CreateFile更改了系统文件，并且查找、查看了注册表

![](G:\code\MalewareAnalysis\lab10\pic2\3.png)

然后，我们使用strings工具对可执行文件进行扫描，发现其是一个内核文件，他的函数以及DDK都证明他是一个影响内核的文件（然后这里明确写了需要Win7的DDK，我在想是不是因为我是xp所以这个sys文件会拷贝的内存的只读位置）

![](G:\code\MalewareAnalysis\lab10\pic2\4.png)

接下来这张图片进一步验证了我们的猜想，资源节的文件会被生成为sys文件，并被命名为Mlwx486放置在System32文件夹下

![](G:\code\MalewareAnalysis\lab10\pic2\5.png)

然后就出现了经典的一幕....加载到内存出错，那也没办法，只能硬着头皮往下做了

![](G:\code\MalewareAnalysis\lab10\pic2\6.png)

既然这样，不如我是用ResourceHacker把sys文件导出然后在idapro下看一看，于是接下来进入高级静态分析的部分：

第二部分：高级静态分析

首先是对exe文件的IDAPro分析，exe文件的结构相对简单，在前面我们已经分析的差不多了，简单的看一下就是：创建一个Mlwx486文件，也就是资源文件中的二进制内容

![](G:\code\MalewareAnalysis\lab10\pic2\7.png)

接下来就是注册服务的过程，果不其然，exe文件将资源节的文件注册为了一个服务，服务的名称就是486 WS Driver，位置就是Mlwx486.sys文件的位置

![](G:\code\MalewareAnalysis\lab10\pic2\8.png)

第三部分：内核调试

由于我的虚拟机抽风，这一部分不得不假手于网上的部分图片，关于Mlwx486.sys的IDa分析会融合如这部分的内核调试。

图片参考网址：[(116条消息) 恶意代码分析实战 Lab 10-2 习题笔记_isinstance的博客-CSDN博客](https://blog.csdn.net/isinstance/article/details/79363150)

那么，我们知道他要在system32下创建了一个sys文件，但是当我们去找的时候却并没有看见这个文件，于是我们大概可以猜到这是一个Rootkit，在虚拟机中使用sc命令查找服务得到如下结果：

![](G:\code\MalewareAnalysis\lab10\pic2\9.png)

在宿主机上对虚拟机进行内核调试，可以观察到确实有一个与静态分析时一致的内核模块被正确加载了：

![](G:\code\MalewareAnalysis\lab10\pic2\10.png)

紧接着，使用命令dd dwo(keServiceDescriptorTable) L100查看SSDT的所有修改项,可以得到如下结果：我们看到有一个内存位置明显偏移于ntoskrnl的模块范围之外，所以也就是说这个sys文件替换覆盖了某一个函数

![](G:\code\MalewareAnalysis\lab10\pic2\11.png)

为了确定到底替换了哪一个函数，我们可以直接使用ResourceHacker导出Vlwx486文件并放置在IDAPro中进行检查：可以看到这里sys文件调用了我们在strings分析时看到的函数

![](G:\code\MalewareAnalysis\lab10\pic2\12.png)

前面的函数还能猜出来，就是初始化一个unicode编码的字符串，然后后面的函数没见过，于是到微软官网查了一下，发现是用来返回一个函数指针的

![](G:\code\MalewareAnalysis\lab10\pic2\15.png)

那么他读入的是哪个函数呢，就是前面初始化化的KeServiceDescriptorTable函数，这个函数是干嘛用的呢，我也不太懂，于是我查了一下:

```c++
KeServiceDescriptorTable 结构 
KeServiceDescriptorTable：是由内核（Ntoskrnl.exe）导出的一个表，这个表是访问SSDT的关键，具体结构是
   typedef struct ServiceDescriptorTable {
   PVOID ServiceTableBase;
   PVOID ServiceCounterTable(0);
   unsigned int NumberOfServices;
   PVOID ParamTableBase;
   }
```

也就是在为之后替换覆盖函数，进行hook攻击做准备

随后我们可以看到一个地址替换：那么在sub_10486位置的是什么东西呢？我们点击进去看一下

![](G:\code\MalewareAnalysis\lab10\pic2\13.png)

是一个函数，这个函数是NtQueryDirectoryFile

![](G:\code\MalewareAnalysis\lab10\pic2\14.png)

这个函数是干嘛用的我也不清楚，于是也是到微软官网查了一下：该函数用于返回给定文件句柄锁指定的目录文件中的各种信息

![](G:\code\MalewareAnalysis\lab10\pic2\16.png)

微软对这个函数的具体描述如下：

在对 **NtQueryDirectoryFile** 的第一次调用中，如果为找到的第一个条目创建的结构太大而不适合输出缓冲区，则例程会将结构的固定部分写入输出缓冲区。 然后，该例程将写入输出缓冲区，使其与 **FileName** 字符串一样多。 (结构固定部分包含除最终 **FileName** 字符串以外的所有字段。在第一次调用（但不在后续调用中）时，I/O 系统可确保缓冲区足够大，足以容纳相应 **FILE_\*XXX\* 的** 固定部分_INFORMATION structure.) 发生这种情况时， **NtQueryDirectoryFile** 将返回适当的状态值，例如STATUS_BUFFER_OVERFLOW。

每次调用时， **NtQueryDirectoryFile** 都会返回尽可能多的 **FILE_\*XXX\*_INFORMATION** 结构 (每个目录条目) ，完全可以包含在 **FileInformation** 指向的缓冲区中。 在第一次调用中，仅当输出缓冲区包含至少一个完整结构时， **NtQueryDirectoryFile** 才会返回STATUS_SUCCESS。 在后续调用中，如果输出缓冲区不包含任何结构，**NtQueryDirectoryFile** 将返回STATUS_SUCCESS，但设置 **IoStatusblock-Information**> = 0 以通知调用方此条件。 在这种情况下，调用方应分配更大的缓冲区并再次调用 **NtQueryDirectoryFile** 。 未报告任何剩余条目的相关信息。 因此，除了上述只返回一个条目的情况下，必须至少调用两次 **NtQueryDirectoryFile** 来枚举整个目录的内容。

那么他是如何做到隐藏文件的呢？FileInformation的结构由一系列FILE_BOTH_DIR_INFORMATION结构组成，这个结构的第一个域指向下一个FILE_BOTH_DIR_INFORMATION结构的偏移量，只要我们能够修改第一个结构的域的指针指向的位置，使其指向第三个结构那么我们就不能看到第二个结构了，也正是运用了这种方式让每个以Mlwx开头的文件都可以被跳过。

Lab10-03：

1、这个程序做了什么？

2、一旦程序运行，该怎么停止他？

3、他的内核组件做了什么？