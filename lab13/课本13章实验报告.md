## 课本实验13实验报告

姓名：魏伯繁 学号：2011395 专业：信息安全

### **一、实验工具：**

IDAPro7.0 IDAPro7.7 win10虚拟机 winxp虚拟机、Wireshark、Ollydbg、strings、ProcessMonitor、Process Explorer、RegShot等

### 二、实验环境：

静态分析主要在win10虚拟机完成。

动态分析在winxp虚拟机上完成

内存4GB

主频2.9GHZ

### 三、实验内容

#### 第一部分：Lab13-01

1.比较恶意代码中的字符串(字符串命令的输出)与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密?

2.使用IDA Pro 搜索恶意代码中字符串xor’，以此来查找潜在的加密，你发现了哪些加密类型?

3.恶意代码使用什么密钥加密，加密了什么内容?

4.使用静态工具FindCrypt2 Krypto ANALyzer (KANAL)以及IDA插件识别一些其他类型的加密机制，你发现了什么?

5.什么类型的加密被恶意代码用来发送部分网络流量?

6.Base64编码函数在反汇编的何处?

7.恶意代码发送的 Base64 加密数据的最大长度是什么?加密了什么内容?

8恶意代码中，你是否在Base64 加密数据中看到了填充字符(=或者==)?

9.这个恶意代码做了什么?

分析过程：

首先我们可以运行Lab13-01.exe来分析其具体的行为，并通过wireshark进行抓包分析。我们可以通过结果简单发现他请求了一个网站www.practicalmalwareanalysis.com:

![](G:\code\MalewareAnalysis\lab13\pic1\1.png)

并且观察抓包结果我们还可以得出他并没有访问成功，只是得到了404的结果：

![](G:\code\MalewareAnalysis\lab13\pic1\2.png)

当然，重点在于，当我们对他的GET请求进行分析时分析出了一些乱码，现在我们还不知道这个乱码的含义，但可以肯定的是这很有可能和我现在使用的计算机系统是相关的

![](G:\code\MalewareAnalysis\lab13\pic1\3.png)

更奇怪的是，如果我们对Lab13-01使用strings工具，可以发现我们并不能观察到其访问的网址以及那个奇怪的乱码字符串，但是我们却可以观察到a-zA-Z0-9，所以我们可以猜测有一些重要字符串被加密了

![](G:\code\MalewareAnalysis\lab13\pic1\4.png)

![](G:\code\MalewareAnalysis\lab13\pic1\5.png)

接下来，我们可以使用静态分析来分析程序是如何运作的：

在IDAPro中搜索XOR指令，并且将一些对库函数的引用去除后我们决定将分析的重点聚焦在sub401190函数中，函数的执行流程图如下图：

很明显它使用了声明的变量var4用做递增计数器，并且用0x3B与缓冲区第一个参数中原始内容的异或结果来修改缓冲区。其他被异或的参数 ，也就是第二个参数是缓冲区的长度。它用静态字节0x3B执行单字节XOR加密，并将缓冲区及其长度作为它的参数。

![](G:\code\MalewareAnalysis\lab13\pic1\6.png)

然后我们需要知道究竟是谁调用了这个函数，并且参数是什么字符串：函数sub401300是调用上面函数的唯一函数。跟踪它调用解密函数之前的代码块，我们依次看到调用GetModuleHandleA、FindResourceA、SizeofResource、GlobalAlloc、LoadResource以及LockResource。调用解密函数之前，恶意代码会对资源做一些处理。在这些资源相关的函数中，我们应该研究让我们找到资源数据的函数FindResourceA。

![](G:\code\MalewareAnalysis\lab13\pic1\7.png)

其中的重点毫无疑问是加载资源的LoadResourceA函数，我们将针对该函数进行具体的分析：其中lpType是0xA，它表示资源数据是应用程序预定义的还是原始数据。lpName既可以是一个名字，也可以是一个索引号。本例中，它是一个索引号。由于函数引用了ID为101的资源

![](G:\code\MalewareAnalysis\lab13\pic1\8.png)

于是我们去PEVIEW中寻找该资源，也就是索引号为0x65的资源，查找也比较简单，打开资源节找到非常醒目的RCDATA就可以找到目标字符串，在资源节偏移0x7060的位置

![](G:\code\MalewareAnalysis\lab13\pic1\9.png)

然后我们使用WinHEX对这部分资源进行转换：

![](G:\code\MalewareAnalysis\lab13\pic1\10.png)

选择转转方式为XOR然后输入要异或的数字3B即可，稍等片刻WINHEX就会帮我们更改目标文件：

![](G:\code\MalewareAnalysis\lab13\pic1\11.png)

有两个字符串也可能被加密，我们发现了域名，但是没有发现GET请求字符串。为了找到GET字符串，我使用PEiD的KANAL插件，它在0x004050F8处找到一个Base64编码表。

![](G:\code\MalewareAnalysis\lab13\pic1\12.png)

随后，我们找到在基本静态分析时找到的典型的Base64编码表的位置，发现他有四个交叉引用，并且全部位于sub401000函数

![](G:\code\MalewareAnalysis\lab13\pic1\13.png)

我们马上来到该函数：

我们可以看到，图中右侧的框中有一个字符=的交叉引用。这证实了我们的判断:sub401000与Base64编码相关，因为在Base64加密中以“=’作为填充字符。调用本函数的函数(4010B1) 是真正的Base64加密函数。它的目的是将源字符串划分成3个字节的块，并且将3个字节块传递给本函数，从而将传入的3个字节加密成4个字一些线索使得这更加明显:函数开头使用strlen查找源字符串的长度，在外部循环(代码块loc 401100)的开头与3比较 ，当本函数返回结果后，在内部写循环的开头与4比较。因此我们得出结论: 前面分析的解密函数就是Base64编码的主函数，他用源字符和Base64加密转换的目的缓冲区作为参数

![](G:\code\MalewareAnalysis\lab13\pic1\14.png)

我们还可以发现一个对前面分析的解密函数逇交叉引用，在4011C9的位置：

看一下传递到解密函数目的字符串，我们看到，它作为sprintf的第4个参数入栈。具体说，以http://%s/%s/(处)格式的第2个字符串是URI的路径。这与我们前面识别的字符串乱码是一致。接下来，我们跟踪传递给解密函数的源字符串，可以看到，它是strncpy函数的输出。并且strncpy的输入是处gethostname的输出。因此，我们可以明白加密的URI路径源字符串是主机名。strncpy函数仅复制了主机名的前12个字节，如所示。

![](G:\code\MalewareAnalysis\lab13\pic1\15.png)

后面的代码它使用了WinINet (InternetopenA、InternetOpenUrIA和InternetReadFile)打开并且读取代码清单解密出的URL。返回数据的第一个字符与字母o比较。如果第一个字母是o，则返回1，否则返回0。主函数由一个循环sleep调用以及beacon调用组成。当beacon (0x004011C9)返回真时(获得以o开始的Web响应)则循环退出程序终止。
概括来说，这个恶意代码发送通信信号beacon，让攻击者知道它在正常运行。恶意代码用加密的(有可能截断)主机名作为标识符发出一个特定的通信信号，当接收到一个特定的回应后，则终

![](G:\code\MalewareAnalysis\lab13\pic1\16.png)

然后，我们希望对生成的文件进行解密，解密的过程为：

我们能够使用OllyDbg来标识两个关键的断点，来实现解密规范策略。第一个断点应该刚好在加密开始之前，所以我们可以使用0x00401880作为断点，这里发生encodingwrapper调用。第二个断点则在第一个文件写入后，所以我们设置在0x0040190A。

![](G:\code\MalewareAnalysis\lab13\pic2\8.png)

使用OllyDbg启动恶意代码以后，设置断点，然后运行程序，则恶意代码将会在第一个断点处(0x00401880)中断。此时，堆栈上的参数表示加密的缓冲区和长度。右击堆栈窗口面板中栈顶的值(该值位于ESP)，然后选择Followin Dump。接下来，在WinHex中打开恶意代码创建的一个加密文件，再选择Edit-CopyAll-Hex Vales。最后在OllyDbg中，选择从转储窗口面板顶部到底部内存块的值 (OllyDbg 要求在粘贴内容之前，选择整个目标区域)。选择的内容是将要进行加密的缓存区，现在我们用文件的内容覆盖它。

![](G:\code\MalewareAnalysis\lab13\pic2\10.png)

现在右击转储窗口面板中十六进制的转储部分，并且选择Binary一Binary Paste。当缓存区准备好以后,运行OllvDbg到最后一个断点。然后，检查恶意代码目录中与先前创建文件具有相同命名约定的新文件。给这个文件一个.bmp扩展名，然后打开它。你应该会看到恶意代码执行过程中抓取的截屏

![](G:\code\MalewareAnalysis\lab13\pic2\9.png)

#### 第二部分：Lab13-02：

1.使用动态分析，确定恶意代码创建了什么?

2.使用静态分析技术，例如 xor 指令搜索、FindCrypt2、KANAL 以及IDA 插件，查找潜在的加密，你发现了什么?

3.基于问题1的回答，哪些导入函数将是寻找加密函数比较好的一个证据?

4.加密函数在反汇编的何处?

5.从加密函数追溯原始的加密内容，原始加密内容是什么?

6.你是否能够找到加密算法?如果没有，你如何解密这些内容?

7.使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件?

分析过程：

首先，双击运行该恶意代码，我们可以观察到，他会在原始目录下创建出很多temp文件，而且文件普遍较大：

![](G:\code\MalewareAnalysis\lab13\pic2\1.png)

使用peid扫描该可执行文件未发现可以被轻易检测的加密证据：

![](G:\code\MalewareAnalysis\lab13\pic2\2.png)

接下来，我们使用静态分析，进入IDAPro搜索XOR指令，去除掉一些库函数的引用、寄存器清零等无特殊含义的异或指令调用，我们可以找到两个很有价值的异或指令：分别位于004012D6和0040176F

尤其要注意位于0x0040171F的xor指令，我们看到它位于一个函数中，但是由于很少使用，这个函数并没有被自动识别。在0x00401570定义函数导致创建包含了前面孤立的xor指令函数。这个未使用的函数也与同组内可能的加密函数有关联。

![](G:\code\MalewareAnalysis\lab13\pic2\3.png)

因为sub401739拥有非常多的xor指令，我们将sub 491739称为Heavy_xor。而sub40128D拥有一条xor指令，我们将sub40128D称为SINGLE_xor。heavyxor带有4个参数，它是一个单循环，除了xor指令以外，拥有包含多个包含SHL和SHR指令的代码块。看一下heavy_xor调用的函数，我们发现singlexor与heavy_xor相关，因为singlexor的调用者也被heavy_xor调用。

![](G:\code\MalewareAnalysis\lab13\pic2\5.png)

为了确定heavyxor的确是一个加密函数，让我们来看一下它与写入到磁盘上temp文件有何种关系我们找到了数据写入到磁盘的位置，然后向前回溯确定怎么使用的加密函数。查看一下导入函数，我们看到了存在函数调用WriteFile。检查一下writeFile的交叉引用，我们找到了sub 401000,它用一个缓冲区，一个缓冲区长度一个文件名作为参数，它打开一个文件并且将缓冲区数据写入到这个文件。我们将sub 401000重命名为writeBufferToFile。sub 401851是调用wirteBufferToFile的唯一函数。下图展示了sub 401851的内容(我们将它命名为doStuffAndwriteFile)，作为0处调用writeBufferToFile函数前的准备

在下图开始的位置，可以发现两处函数调用sub401070和sub 40181F它们都是用缓冲区以及缓冲区的长度作为参数。结合GetTickCount 结果的格式化字符串"temp%08x”发现了原文件名，它是当前时间的十六进制打印。IDA Pro已经标注了文件名，我们可以猜测处的sub 40170用来获取内容(我们称它为getContent)，sub_40181F用来加密内容(我们重命名为encodingwrapper)

首先看一下我们假设的加密函数encodingwrapper(在0x0040181F)，可以看到它仅仅是一个heavy_xor函数的封装器。这证实了我们前面的猜想所说的该函数是加密函数。函数encodingwrapper首先设置了4个加密的参数:一个使用之前清空的本地变量，从dostuffAndwriteFile传递过来指向同-个缓冲区的两个指针以及一个从dostuffAndwriteFile传递过来的缓冲区大小。两个指针指向同一个内存缓冲区暗示编码函数携带源和目的缓冲区以及一个长度，这种情况下，加密将在适当的地方执行。

![](G:\code\MalewareAnalysis\lab13\pic2\6.png)

接下来，我们确定加密并且写入磁盘的原始内容。如前面提到的一样，函数getContent(在0x00401070)似乎获取一些内容。看一下getContent，我们看到一个拥有多个系统函数的代码块。

我们可以根据他的系统函数调用列表进行猜测，一种较好的猜测是:这个函数试图抓屏。值得注意的是，GetDesktopwindow获取覆盖整个屏幕桌面窗口的一个句柄，函数BitBlt和GetDIBits(粗体所示)获取位图信息并将它们复制到缓冲区。因此，我们得出结论，恶意代码反复抓取用户的桌面并且将加密版本的抓屏信息写入到一个文件

![](G:\code\MalewareAnalysis\lab13\pic2\7.png)





#### 第三部分：Lab13-03：

1.比较恶意代码的输出字符串和动态分析提供的信息，通过这些比较，你发现哪些元素可能被加案?

2.使用静态分析搜索字符 xor 来查找潜在的加密。通过这种方法，你发现什么类型的加密?

3使用静态工具，如 FindCvpt2、KANAL 以及DA 插件识别一些其他类型的加案机制。发现的结果与搜索字符XOR结果比较如何?

4.恶意代码使用哪两种加密技术?

5.对于每一种加密技术，它们的密钥是什么?

6.对于加密算法，它的密钥足够可靠吗?另外你必须知道什么?

7.恶意代码做了什么?

8.构造代码来解密动态分析过程中生成的一些内容，解密后的内容是什么?

