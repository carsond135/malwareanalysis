## 课本第十一章实验报告

专业：信息安全 姓名：魏伯繁 学号：2011395

第一部分：

Lab11-01

1、这个恶意代码向磁盘释放了什么？

2、这个恶意代码如何进行驻留？

3、这个恶意代码如何窃取用户的登录凭证？

4、这个恶意代码对窃取的证书做了什么处理？

5、如何在你的测试环境让这个恶意代码获得用户的登录凭证？

分析过程：

基本静态分析：使用strings查看exe文件中对应的字符串可以看到存在第一个gina.dll并且由很多已Wlx开头的字符串，所以说他很有可能是一个拦截GINA的恶意代码

![](G:\code\MalewareAnalysis\lab11\pic1\1.png)

在这张图片中，同样我们也看到了一个注册表的路径以及相应的硬件驱动，于是根据这些我们可以猜测该恶意代码通过修改注册表完成拦截GINA的操作，并且配合一些驱动完成相应工作

![](G:\code\MalewareAnalysis\lab11\pic1\2.png)

通过PEbrowser可以看到，他在资源节存在一个TGAD，点开看发现是一个PE文件，那么这个PE文件很可能就是exe文件想要下载导入的文件：

![](G:\code\MalewareAnalysis\lab11\pic1\3.png)

再通过查看该文件的导入表，我们也可以确认上面的猜想，导入表中存在对资源节的加载以及对注册表的修改函数：

![](G:\code\MalewareAnalysis\lab11\pic1\4.png)

![](G:\code\MalewareAnalysis\lab11\pic1\5.png)

第二部分：基本动态分析

我们在xp虚拟机上使用process Explorer和process monitor监视进程的改变并监视Lab11-01的行为，并通过RegShot对注册表进行快照，首先观察RegShot的结果：发现他确实更改了注册表，恶意代码插入了msgina.dll的路径到注册表GINA，所以当系统自启动时WinLogon会加载这个DLL

![](G:\code\MalewareAnalysis\lab11\pic1\6.png)

再查看Process Monitor的内容，成功发现了一个CreateFile的动作，他创建了一个msgina32.dll的动态链接库，具体的位置就在和Lab11-01.exe同级的目录下

![](G:\code\MalewareAnalysis\lab11\pic1\7.png)

![](G:\code\MalewareAnalysis\lab11\pic1\9.png)

再查看Winlogon.exe下的dll，我们发现确实是存在一个msgina.dll的动态链接库的，但是这个dll是在system32下的，也就是干净的dll，说明这个时候恶意代码的dll还未被加载

![](G:\code\MalewareAnalysis\lab11\pic1\8.png)

于是我们关机重启，发现他给我弹了一个弹窗，也就是弹出了一个开机启动输入密码的界面，所以我们可以大概知道这个恶意代码要记录用户的笔记本上的的账号和密码

![](G:\code\MalewareAnalysis\lab11\pic1\11.png)

这个时候我们再打开Process Explorer发现，一个被恶意代码生成的msgina32就被生成并动态加载了

![](G:\code\MalewareAnalysis\lab11\pic1\10.png)

然后我们通过ResourceHacker来分析其导出的dll，发现他和在xp机上生成的msgina32是一致的，所以我们分析该dll，再次分析dll的strings，我们大概可以判断，格式化的输出其实是记录了用户的账号和密码信息

![](G:\code\MalewareAnalysis\lab11\pic1\12.png)

第三步：使用高级静态分析

使用IDAPro分析msgina.dll文件，首先可以看到该dll对参数进行检查：即对第二个参数进行检查，如果不是1的话就退出

![](G:\code\MalewareAnalysis\lab11\pic1\13.png)

接下来，如果参数正确，就执行后面的代码，通过调用LoadLibraryW函数获取Windows系统中msgina.dll的句柄，然后再将这个句柄存入hLibMoudle中，这样的话就可以让恶意代码可以正常的响应响应的对msgina.dll的请求，因为msgina32拦截了Winlogon和msgina的通信，所以msgina32相当于要帮助分发正常的系统调用

![](G:\code\MalewareAnalysis\lab11\pic1\14.png)

然后我们查看该dll的导出函数，我们以WLxLoggdOnSAS进行说明：这个函数非常简单，首先传递字符串WLxLoggdOnSAS到sub_10001000，然后跳转到程序入口地址，函数sub_10001000传入msgina.dll的句柄和想要调用的函数WLxLoggdOnSAS来使用GetProcessAddress解析msgina中的函数地址，然后跳转到该函数，通过跳转并调用WLxLoggdOnSAS，这段代码并不会创建一个栈帧或者将返回地址压栈，所以他将直接在Winlogon上运行，就像什么都没发生过一样

![](G:\code\MalewareAnalysis\lab11\pic1\15.png)

下图是对应的10001000处的代码，通过函数名寻找对应应该跳转的地址

![](G:\code\MalewareAnalysis\lab11\pic1\16.png)

其他大部分的导出函数都与WLxLoggdOnSAS的操作过程基本一致，除了WLxLoggdOutSA函数以外：他在完成这些常规操作之后又进行了后续的很多操作：

![](G:\code\MalewareAnalysis\lab11\pic1\17.png)

后面的代码将那个格式化字符串压栈当做参数后调用了一个其他位置的函数：

![](G:\code\MalewareAnalysis\lab11\pic1\18.png)

10001570位置的代码看起来像是一个记录窃取登录凭证的函数，首先传入被当做参数传入的格式化字符串，然后打开msutil32.sys文件，因为Winlogon在C:\Windows\System32的目录下，所以这个文件也被创建在该目录下，接下来记录日期时间最后记录登录的凭证，所以说，这个sys文件并不是一个驱动，只是记录记录凭证信息的文件。

![](G:\code\MalewareAnalysis\lab11\pic1\19.png)

然后我们可以查看具体的该文件下的记录：发现和我们分析的一致

![](G:\code\MalewareAnalysis\lab11\pic1\20.png)

Lab11-02



分析过程：

第一部分：基本静态分析，使用strings工具可以观察到，其中APPInit_DLLs和后面的一个注册表的路径用来永久安装自身，后面的ini文件说明该动态链接库使用了ini文件，其中RCPT TO这个字符串说明了：RCPT是一个命令，用来创建一个电子邮件的接收人

![](G:\code\MalewareAnalysis\lab11\pic2\1.png)

然后再通过PEBrowser查看他的导入导出表：他具有一个导出表installer，应该是要安装一个可执行文件或一些可执行的进程，导入表包括对注册表的修改以及搜索一个进程线程列表的导入函数。

![](G:\code\MalewareAnalysis\lab11\pic2\2.png)

根据查找微软官方文档我们可以名曲该函数的使用：

![](G:\code\MalewareAnalysis\lab11\pic2\3.png)

然后我们对ini文件进行静态分析，发现他并没有提供什么有用的信息，并且他似乎被加密了

![](G:\code\MalewareAnalysis\lab11\pic2\4.png)

第二步：基本动态分析

使用命令rundll32.exe Lab11-02.dll,install 执行dll文件，通过procmon可以观察到恶意代码在系统目录下创建了一个spoolvxx32.dll的文件，并且这个dll文件其实就是Lab11-02.dll文件

![](G:\code\MalewareAnalysis\lab11\pic2\5.png)

然后我么根据regshot可以看到恶意代码将spoolvxx32,dll添加到AppInit_Dlls列表中，这样的话恶意代码就会被加载到所有装载User32.dll的进程中

![](G:\code\MalewareAnalysis\lab11\pic2\6.png)

然后，我们在procmon中也可以看到在系统目录下打开ini文件的请求，这表明我们需要将ini文件移动到系统目录下

![](G:\code\MalewareAnalysis\lab11\pic2\7.png)

第三步：使用高级静态分析

使用IdaPro打开dll文件，然后分析其调用的函数：我们发现这个installer的具体功能和我们之前观察过的基本一致，也就是修改注册表的值然后对文件进行读取、写入

![](G:\code\MalewareAnalysis\lab11\pic2\8.png)

然后我们进入函数的内部进行分析：首先和上一个程序一致的是他在一开始的时候检查了参数的状态，如果参数不符合要求则直接退出

![](G:\code\MalewareAnalysis\lab11\pic2\9.png)

接下来的程序实现的功能是：首先获取Windows的系统目录以及一个字符串代表的接下来的目录lab11-02.ini，最终使用strncat将他们组合成一个完整的路径，并且在最后打开这个文件，如果打开失败也直接退出

![](G:\code\MalewareAnalysis\lab11\pic2\10.png)

如果成功获取了ini文件，然后就需要将他读入缓冲区，但是我们通过strings程序读取ini文件中的字符串时看到的是里面是一堆乱码，所以很有可能里面的内容需要解密才能获取到其中的内容。那么读入后调入的第一个函数很可能就是对应的解密函数

![](G:\code\MalewareAnalysis\lab11\pic2\11.png)

为了获取其解密之后的结果，我们利用ollydbg对其进行动态调试：在读取文件的位置设置断点并观察其执行过程，可以看到，当读取完ini函数的地址后再使用strcat，eax的值变成了整个lab11-02.ini路径的值的字符串，于是我们可以读取该位置的文件

![](G:\code\MalewareAnalysis\lab11\pic2\12.png)

接下来，我们使用F8进行step over的形式进行调试，因为我们并不关注其内部是怎么执行的，于是我们得到的解密结果为一个emai的地址：放大后我们可以看到他的具体内容：billy@malwareanalysisbook.com,此时eax的值正在指向他，这个邮箱的内容存在全局变量中

![](G:\code\MalewareAnalysis\lab11\pic2\13.png)

![](G:\code\MalewareAnalysis\lab11\pic2\14.png)

于是，我们可以将byte_100034A0的变量值的名称修改为mailAdress便于后面的识别

![](G:\code\MalewareAnalysis\lab11\pic2\15.png)

接下来，恶意代码调用GetModuleFileNameA函数，因为在调用这个参数之前，它的参数hMoudle被置为0，所以函数会加载这个DLL的绝对路径，接下来恶意代码在arg_4中返回路径名

![](G:\code\MalewareAnalysis\lab11\pic2\16.png)

接下来，将当前进程的大写字母与THEBAT.EXE和OUTLOOK.EXE以及MSIMN.EXE互相比较，如果进程名不等于其中任何一个就退出，如果恶意代码已经载入了这三个中的一个那么后面的代码就会运行

![](G:\code\MalewareAnalysis\lab11\pic2\17.png)

接下来的代码sub_10010BD处的代码进行了一系列操作，其具体的流程在下面两张图中有所体现。根据下面的分析，我们可以知道在sub_100013BD中暂停了其他的所有线程。通过后面的分析我们又知道，1499位置的函数将之前所有挂起的线程全部都恢复了，那么我们可以合理猜测，在这中间可能要做一些可能会改变进程运行状况的动作，比如改变内核或者安装一个inline挂钩。

![](G:\code\MalewareAnalysis\lab11\pic2\18.png)

下面两张图详细展示了100013BD的函数具体流程，首先该函数调用了GetCurrentProcessId函数用来返回当前进程的标识符，然后紧接着调用了100012FE函数，这个函数调用了GetCurrentThreadId函数用来返回当前进程的标识符，接下来调用CreateToolhelp32SnapShot，并且遍历当前进程的所有Tid，如果Tid不是当前的线程那么就将这些进程暂停，所以说这个函数刮起了当前其他的进程。

![](G:\code\MalewareAnalysis\lab11\pic2\19.png)

![](G:\code\MalewareAnalysis\lab11\pic2\20.png)

接下来，我们可以看到位于1499的函数最终调用了ResumeThread函数将之前暂停的线程全部恢复了。

![](G:\code\MalewareAnalysis\lab11\pic2\21.png)

接下来，我们分析中间的函数，观察在所有的TID中断的这段时间里发生了什么，首先他的两个参数我们是已知的，分别是send和wsock32.dll，

![](G:\code\MalewareAnalysis\lab11\pic2\22.png)

并且通过这句GetMoudleHandleA获得了所需要的dll的句柄，接下来马上传递相应的参数到1203的位置继续执行相应函数

![](G:\code\MalewareAnalysis\lab11\pic2\23.png)

那么这个函数究竟是怎么完成挂钩函数的呢？代码通过计算send函数和内存地址sub_1000113D开始的内存地址之间的差，再将差值移到var_4变量之前，需要从中再减去5个字节，随后的代码在使用var_4的时候可以通过在前面直接加入jmp然后跳转到sub_1000113D函数的位置。

![](G:\code\MalewareAnalysis\lab11\pic2\25.png)

然后在后面我们就看到：在send函数的开头复制了0E9h，这个机器码的意思就是jmp，之后就将代码赋值var_4到0xe9之后的内存，于是我们就可以通过这样一个简单的指令设置跳转到DLL中的sub_1000113D函数

![](G:\code\MalewareAnalysis\lab11\pic2\26.png)

在接下来的动作中：VirtualProtect函数的调用修改了内存的运行。读以及写权限，因此可以修改恶意代码中的send函数的可执行性，在函数末尾的VirtualProtest则恢复原有的保护，随后使用alloc函数分配256字节的内存并将结果保存在Var_8中

![](G:\code\MalewareAnalysis\lab11\pic2\27.png)

然后我们再次查看恶意代码是如何填充这256个字节的代码的：首先，使用memcpy进行复制send的前五个字节，因为恶意代码覆盖了前5个字节，因此需要确保保存了原始指令。恶意代码假设send函数前几条指令严格按照5个字节对齐

接下来在0E9h和后面的添加跳转的地址，这样一个跳转指令就成功的进行了初始化，最后在函数的末尾将全局变量10003484设置为了这个缓冲区的地址

![](G:\code\MalewareAnalysis\lab11\pic2\28.png)

挂钩函数在buf中查找字符串RCPT TO，如果没有发现这个字符串那么一切如常，就是正常的去send函数中去调用相应的代码，反之会向mailaddress位置的客户发送一个邮件，而这个用户就是billy@malwareanalysisbook.com,这段代码向所有发出的邮件都添加了一个收件人

![](G:\code\MalewareAnalysis\lab11\pic2\29.png)